<!DOCTYPE HTML>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <meta content="utf-8" http-equiv="encoding"/>
    <title>Tetris Example </title>
    
    <!-- THIS FIRST -->
    <script src="jquery-1.11.2.min.js"></script> <!-- 1 - JQUERY -->
    <script src="Pixi/bin/pixi.js"></script>  
    <script src="model/shape.js"></script>  

    
</head>

<body>

  <div class="c4"> </div>

<script>
   "use strict";
     // 7 colors, red, green, blue, yellow, baby blue, orange, purple
     var color_array = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff8000, 0xbf00ff];
     var color_index = 0;
     var rotation_index = 0;
     class Piece {
        constructor(container, i, j) {

        color_index = Math.floor((Math.random() * 7) + 1) - 1
        rotation_index = Math.floor((Math.random() * 4) + 1) - 1

        // this is a L
        if (color_index % 7 == 0) {

          var L = new L1(rotation_index)

          this.values = L.positions[L.rotation]
      }
        //  this is an J
        else if(color_index % 7 == 1)
        {
            var J = new L2(rotation_index)

            this.values = J.positions[J.rotation]
       }
        // this is a T
        else if(color_index % 7 == 2)
        {
            var T = new Pyramid(rotation_index)

            this.values = T.positions[T.rotation]
       }
        // square
        else if(color_index % 7 == 3)
        {
            var square = new Square()

            this.values = square.positions[0]
        }
        //  line
        else if(color_index % 7 == 4)
        {
            var line = new Line(rotation_index)

            this.values = line.positions[line.rotation]
        }
        //  zag 1
        else if(color_index % 7 == 5)
        {
            var z1 = new Zag1(rotation_index)

            this.values = z1.positions[z1.rotation]
        }
        //  zag 2
        else {
            var z2 = new Zag2(rotation_index)

            this.values = z2.positions[z2.rotation]
       }


       this.i = 0;
       this.j = 0;
       this.color = color_array[color_index];
       //color_index = (color_index + 1) % 7
   }
   down() {
    this.j++
}
up() {
    this.j--
}
left() {
    this.i--;
    if (this.i < 0) {
        this.i = 0
    }
}
right() {
    this.i++;
    if (this.i > 9) {
        this.i = 9
    }
}
draw(matrix) {
    for (var i = 0; i < this.values.length; i++) {
        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
        cell.visible = true;
        cell.color = this.color;
        cell.draw()
    }
}
fill(matrix) {
    for (var i = 0; i < this.values.length; i++) {
        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
        cell.visible = true;
        cell.color = this.color;
        cell.filled = true;
        cell.draw()
    }
}
conflict(matrix) {
    for (var i = 0; i < this.values.length; i++) {
        var i_offset = this.i + this.values[i][0];
        var j_offset = this.j + this.values[i][1];
        if (j_offset >= 20) return true;
        var cell = matrix[i_offset][j_offset];
        console.log(cell);
        if (cell.filled) return true
    }
return false
}
}
class Cell {
    constructor(container, i, j) {
        this.square = new PIXI.Graphics();
        container.addChild(this.square);
        this.square.x = i * 25;
        this.square.y = j * 25;
        this.square.mouseover = function() {
            console.log("mouse over")
        };
        this.filled = false;
        this.color = 0xffffff
    }
    draw() {
        this.square.clear();
        this.square.beginFill(this.color);
        this.square.drawRect(0, 0, 25, 25);
        this.square.endFill()
    }
    set visible(value) {
        this.square.visible = value
    }
}
class Tetris {
    constructor(stage) {
        console.log("constructor for tetris");
        this.board = new PIXI.Sprite();
        this.outline = new PIXI.Graphics();
        this.board.x = 50;
        this.board.y = 50;
        this.draw_outline();
        this.board.addChild(this.outline);
        this.build_matrix(this.board);
        stage.addChild(this.board);
        this.current_piece = new Piece();
        this.draw_piece();
        document.addEventListener('keydown', this.handle_key_presses.bind(this))
        window.addEventListener("keydown", function(e) {
		    // space and arrow keys
		    if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
		        e.preventDefault();
		    }
		}, false);
    }
    handle_key_presses(key) {
        if (key.code == "ArrowDown") {
            this.current_piece.down();
            if (this.current_piece.conflict(this.board_matrix)) {
                this.current_piece.up();
                this.current_piece.fill(this.board_matrix);
                this.current_piece = new Piece();
                this.draw_piece()
            }
        }
        if (key.code == "ArrowLeft") {
            this.current_piece.left();
            if (this.current_piece.conflict(this.board_matrix)) {
                this.current_piece.right()
            }
        }
        if (key.code == "ArrowRight") {
            this.current_piece.right();
            if (this.current_piece.conflict(this.board_matrix)) {
                this.current_piece.left()
            }
        }
        this.clear_board();
        this.draw_piece()
    }
    draw_piece() {
        this.current_piece.draw(this.board_matrix)
    }
    build_matrix(container) {
        this.board_matrix = [];
        for (var i = 0; i < 10; i++) {
            this.board_matrix[i] = [];
            for (var j = 0; j < 20; j++) {
                this.board_matrix[i][j] = new Cell(container, i, j);
                this.board_matrix[i][j].visible = false
            }
        }
    }
    clear_board() {
        for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 20; j++) {
                this.board_matrix[i][j].draw();
                if (this.board_matrix[i][j].filled) {
                    this.board_matrix[i][j].visible = true
                } else {
                    this.board_matrix[i][j].visible = false
                }
            }
        }
    }
    draw_outline() {
        this.outline.clear();
        this.outline.lineStyle(2, 0xCCCCCC);
        this.outline.beginFill();
        this.outline.drawRect(0, 0, 250, 500);
        this.outline.endFill()
    }
}
var stage;
var renderer;

function doit() {
    $("body").append("hello")
}

function after_load() {
    stage = new PIXI.Container();
    stage.interactive = true;
    renderer = PIXI.autoDetectRenderer(500, 1000, null);
    document.body.appendChild(renderer.view);
    requestAnimationFrame(animate);
    new Tetris(stage)
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(stage)
}
after_load();


</script>